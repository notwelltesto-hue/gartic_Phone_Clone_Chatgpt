<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gartic Phone Clone</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div id="container">

    <!-- HOME -->
    <div id="homeScreen" class="active">
      <h1>Gartic Phone</h1>

      <div class="row">
        <button id="btnCreatePublic">Create Public Lobby</button>
        <button id="btnCreatePrivate">Create Private Lobby</button>
        <input id="joinCodeInput" placeholder="Lobby code (5 chars)" maxlength="5" />
        <button id="btnJoinLobby">Join</button>
      </div>

      <div style="display:flex; gap:12px;">
        <div style="flex:1;">
          <h3>Public lobbies</h3>
          <div id="lobbiesList">(loading...)</div>
        </div>
        <div style="width:280px;">
          <h3>Quick info</h3>
          <div id="homeStatus">Create a lobby or join with a code.</div>
        </div>
      </div>
    </div>

    <!-- GAME -->
    <div id="gameScreen">
      <div class="row">
        <label for="name">Name:</label>
        <input id="name" placeholder="Your name (optional)" maxlength="20" />
        <button id="startGameBtn" style="margin-left:auto;">Start Game</button>
      </div>

      <div id="players">(waiting...)</div>
      <div id="phaseInfo">Waiting for host to start</div>
      <div id="timer"></div>

      <div id="inputSection">
        <textarea id="inputText" placeholder="Type here..." ></textarea>
        <canvas id="inputCanvas" width="640" height="440"></canvas>
        <div>
          <button id="submitBtn" disabled>Submit</button>
          <button id="copyCodeBtn" style="margin-left:8px; display:none;">Copy Lobby Code</button>
        </div>
        <div id="status"></div>
      </div>

      <div id="chain"></div>
    </div>

  </div>

<script>
(() => {
  const wsProtocol = location.protocol === 'https:' ? 'wss://' : 'ws://';
  const ws = new WebSocket(wsProtocol + location.host);

  // Elements
  const homeScreen = document.getElementById('homeScreen');
  const gameScreen = document.getElementById('gameScreen');
  const lobbiesList = document.getElementById('lobbiesList');
  const homeStatus = document.getElementById('homeStatus');
  const joinCodeInput = document.getElementById('joinCodeInput');
  const btnJoinLobby = document.getElementById('btnJoinLobby');
  const btnCreatePublic = document.getElementById('btnCreatePublic');
  const btnCreatePrivate = document.getElementById('btnCreatePrivate');

  const nameInput = document.getElementById('name');
  const playersEl = document.getElementById('players');
  const phaseInfo = document.getElementById('phaseInfo');
  const timerEl = document.getElementById('timer');
  const inputText = document.getElementById('inputText');
  const inputCanvas = document.getElementById('inputCanvas');
  const submitBtn = document.getElementById('submitBtn');
  const chainEl = document.getElementById('chain');
  const statusEl = document.getElementById('status');
  const startGameBtn = document.getElementById('startGameBtn');
  const copyCodeBtn = document.getElementById('copyCodeBtn');

  // State
  const clientId = Math.random().toString(36).slice(2,9);
  let currentLobby = null;
  let players = {};
  let playerOrder = [];
  let chain = [];
  let currentPhase = -1;
  let currentPlayerId = null;
  let currentInputType = null;
  let canInput = false;
  let lobbyCode = null;
  let lobbyIsHost = false;

  // Drawing setup
  const ctx = inputCanvas.getContext('2d');
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.strokeStyle = '#f5a623';
  ctx.lineWidth = 4;
  let drawing = false;
  let drawCommands = [];

  // Helpers
  function showHome(){ homeScreen.classList.add('active'); gameScreen.classList.remove('active'); }
  function showGame(){ homeScreen.classList.remove('active'); gameScreen.classList.add('active'); }

  function resetInputUI(){
    inputText.style.display = 'none';
    inputCanvas.style.display = 'none';
    submitBtn.disabled = true;
    inputText.value = '';
    drawCommands = [];
    ctx.clearRect(0,0,inputCanvas.width,inputCanvas.height);
    statusEl.textContent = '';
    stopTimer();
  }

  // Timer
  let timerInterval = null;
  function startTimer(sec = 30){
    clearInterval(timerInterval);
    let t = sec;
    timerEl.textContent = `Time left: ${t}s`;
    timerInterval = setInterval(()=>{
      t--;
      if (t<=0){ clearInterval(timerInterval); timerEl.textContent=''; submitBtn.click(); return; }
      timerEl.textContent = `Time left: ${t}s`;
    },1000);
  }
  function stopTimer(){ clearInterval(timerInterval); timerEl.textContent=''; }

  function announce(text){
    if ('speechSynthesis' in window){
      speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text);
      speechSynthesis.speak(u);
    }
  }

  // Render limited chain context (only previous entry)
  function renderChain(){
    chainEl.innerHTML = '';
    if (currentPhase <= 0) return;
    const prev = chain[currentPhase - 1];
    if (!prev) return;
    const div = document.createElement('div');
    div.className = 'chain-entry';
    if (currentInputType === 'drawing' && prev.type === 'text'){
      div.innerHTML = `<div class="chain-text">${prev.content}</div>`;
    } else if (currentInputType === 'text' && prev.type === 'drawing'){
      const c = document.createElement('canvas');
      c.className = 'chain-canvas';
      c.width = 640; c.height = 440;
      div.appendChild(c);
      const cx = c.getContext('2d');
      cx.lineCap='round'; cx.lineJoin='round'; cx.strokeStyle = prev.brush.color; cx.lineWidth = prev.brush.size;
      cx.beginPath();
      prev.commands.forEach(cmd=>{
        if (cmd.type==='begin') cx.moveTo(cmd.x,cmd.y);
        else if (cmd.type==='stroke') cx.lineTo(cmd.x,cmd.y);
        else if (cmd.type==='end') cx.closePath();
      });
      cx.stroke();
    } else {
      div.textContent = '(No context available)';
    }
    chainEl.appendChild(div);
  }

  // Update players display
  function updatePlayers(){
    playersEl.innerHTML = '';
    if (!playerOrder || playerOrder.length===0){ playersEl.textContent='(No players)'; return; }
    playerOrder.forEach(id=>{
      const d = document.createElement('div');
      d.className = 'player-name' + (id===currentPlayerId ? ' player-current' : '');
      d.textContent = (players[id] && players[id].name) ? players[id].name : id;
      playersEl.appendChild(d);
    });
  }

  // Input toggles
  function showInput(type, allowed){
    resetInputUI();
    currentInputType = type;
    canInput = allowed;
    if (!type){ statusEl.textContent = 'Waiting...'; return; }

    if (!allowed){
      statusEl.textContent = `Waiting for ${players[currentPlayerId] ? players[currentPlayerId].name : currentPlayerId} to ${type==='text' ? 'write' : 'draw'}...`;
    } else {
      statusEl.textContent = `Your turn to ${type==='text' ? 'write a prompt' : 'draw the prompt'}`;
    }

    if (type==='text'){
      if (allowed) { inputText.style.display='block'; inputText.focus(); submitBtn.disabled=false; }
      else inputText.style.display='none';
    } else {
      if (allowed) { inputCanvas.style.display='block'; submitBtn.disabled=false; }
      else inputCanvas.style.display='none';
    }
    renderChain();
  }

  // Canvas events
  function toCanvasPos(e){
    const rect = inputCanvas.getBoundingClientRect();
    const scaleX = inputCanvas.width / rect.width;
    const scaleY = inputCanvas.height / rect.height;
    const x = ((e.clientX ?? (e.touches && e.touches[0].clientX)) - rect.left) * scaleX;
    const y = ((e.clientY ?? (e.touches && e.touches[0].clientY)) - rect.top) * scaleY;
    return { x,y };
  }
  inputCanvas.addEventListener('pointerdown', (e)=>{ if (!canInput || currentInputType!=='drawing') return; drawing=true; const p=toCanvasPos(e); drawCommands.push({type:'begin',x:p.x,y:p.y}); ctx.beginPath(); ctx.moveTo(p.x,p.y); });
  inputCanvas.addEventListener('pointermove', (e)=>{ if (!drawing) return; const p=toCanvasPos(e); drawCommands.push({type:'stroke',x:p.x,y:p.y}); ctx.lineTo(p.x,p.y); ctx.stroke(); });
  window.addEventListener('pointerup', ()=>{ if (drawing){ drawing=false; drawCommands.push({type:'end'}); } });

  // Submit handler
  submitBtn.addEventListener('click', ()=>{
    if (!canInput) return;
    if (currentInputType==='text'){
      const content = inputText.value.trim();
      if (!content) { alert('Enter text'); return; }
      ws.send(JSON.stringify({ t:'input', id: clientId, type:'text', content }));
      resetInputUI();
      stopTimer();
    } else if (currentInputType==='drawing'){
      if (drawCommands.length===0){ alert('Draw something'); return; }
      ws.send(JSON.stringify({ t:'input', id: clientId, type:'drawing', commands: drawCommands, brush: { color: ctx.strokeStyle, size: ctx.lineWidth }}));
      resetInputUI();
      stopTimer();
    }
  });

  // Lobby + home interactions
  function joinLobby(code){
    if (!code || code.length!==5) { alert('Enter 5-char code'); return; }
    lobbyCode = code.toUpperCase();
    showGame();
    ws.send(JSON.stringify({ t:'joinLobby', code: lobbyCode, id: clientId, name: nameInput.value || '' }));
    copyCodeBtn.style.display='inline-block';
    copyCodeBtn.onclick = ()=>{ navigator.clipboard?.writeText(lobbyCode).then(()=>alert('Copied!')); };
  }

  btnCreatePublic.onclick = ()=> ws.send(JSON.stringify({ t:'createLobby', isPublic: true }));
  btnCreatePrivate.onclick = ()=> ws.send(JSON.stringify({ t:'createLobby', isPublic: false }));
  btnJoinLobby.onclick = ()=> joinLobby(joinCodeInput.value);
  startGameBtn.onclick = ()=> ws.send(JSON.stringify({ t:'startGame' }));

  // Name change notifies server by re-joining (simpler)
  nameInput.addEventListener('change', ()=>{ if (!lobbyCode) return; ws.send(JSON.stringify({ t:'joinLobby', code:lobbyCode, id:clientId, name: nameInput.value || '' })); });

  // WebSocket events
  ws.addEventListener('open', ()=> { ws.send(JSON.stringify({ t:'listLobbies' })); showHome(); });

  ws.addEventListener('message', (ev)=>{
    let msg; try { msg = JSON.parse(ev.data); } catch { return; }
    if (msg.t==='publicLobbies'){
      if (!msg.lobbies || msg.lobbies.length===0) { lobbiesList.textContent='(no public lobbies)'; return; }
      lobbiesList.innerHTML = '';
      msg.lobbies.forEach(l=>{
        const d = document.createElement('div'); d.className='lobby-item';
        d.innerHTML = `<div>${l.code}</div><div>${l.players} players</div>`;
        d.onclick = ()=> joinLobby(l.code);
        lobbiesList.appendChild(d);
      });
      return;
    }
    if (msg.t==='lobbyCreated'){
      homeStatus.textContent = `Lobby created. Code: ${msg.code} (${msg.isPublic ? 'public' : 'private'})`;
      joinLobby(msg.code);
      return;
    }
    if (msg.t==='error'){ alert(msg.msg); return; }

    if (msg.t==='playersUpdate'){
      players = msg.players || {}; playerOrder = msg.order || []; currentPhase = -1;
      lobbyIsHost = (msg.hostId === clientId);
      if (lobbyIsHost) startGameBtn.style.display='inline-block'; else startGameBtn.style.display='none';
      updatePlayers();
      return;
    }

    if (msg.t==='chainUpdate'){ chain = msg.chain || []; renderChain(); return; }

    if (msg.t==='phaseStart'){
      currentPhase = msg.phaseIndex;
      currentPlayerId = msg.playerId;
      currentInputType = msg.inputType;
      updatePlayers();
      phaseInfo.textContent = `Phase ${currentPhase+1}: ${players[currentPlayerId] ? players[currentPlayerId].name : currentPlayerId} to ${currentInputType==='text' ? 'write' : 'draw'}`;
      const amCurrent = (clientId === currentPlayerId);
      showInput(currentInputType, amCurrent);
      if (amCurrent) { announce(`Your turn to ${currentInputType==='text' ? 'write' : 'draw'}`); startTimer(msg.time || 30); }
      else { startTimer(msg.time || 30); }
      return;
    }

    if (msg.t==='gameEnded'){ statusEl.textContent='Game ended. Host can restart.'; resetInputUI(); return; }
  });

})();
</script>
</body>
</html>
