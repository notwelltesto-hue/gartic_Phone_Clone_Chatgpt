<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gartic Phone Clone</title>
  <style>
    body {
      font-family: system-ui,Segoe UI,Roboto,Arial;
      display: flex;
      gap: 12px;
      padding: 12px;
    }
    #ui {
      width: 320px;
      max-height: 600px;
      overflow-y: auto;
    }
    #players {
      border: 1px solid #ddd;
      padding: 6px;
      white-space: pre-line;
      max-height: 100px;
      overflow-y: auto;
      margin-bottom: 12px;
    }
    #chain {
      border: 1px solid #ccc;
      padding: 6px;
      max-height: 400px;
      overflow-y: auto;
    }
    .chain-entry {
      border-bottom: 1px solid #eee;
      padding: 6px 0;
    }
    canvas.chain-canvas {
      border: 1px solid #aaa;
      display: block;
      margin: 6px 0;
      width: 300px;
      height: 200px;
      touch-action: none;
    }
    #inputSection {
      margin-top: 12px;
    }
    #inputText {
      width: 100%;
      font-size: 1rem;
      padding: 6px;
      box-sizing: border-box;
    }
    #inputCanvas {
      border: 1px solid #444;
      width: 300px;
      height: 200px;
      touch-action: none;
      display: none;
    }
    #submitBtn {
      margin-top: 8px;
      padding: 8px 12px;
      font-size: 1rem;
    }
    #status {
      margin-top: 8px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div id="ui">
    <h3>Gartic Phone Clone</h3>

    <label>Username: <input id="name" placeholder="player123" /></label>

    <div id="players">(no players yet)</div>

    <div>
      <strong>Current phase info:</strong>
      <div id="phaseInfo">Loading...</div>
    </div>

    <div id="chain"></div>

    <div id="inputSection">
      <textarea id="inputText" rows="3" placeholder="Type your prompt or description"></textarea>
      <canvas id="inputCanvas" width="300" height="200"></canvas>
      <br/>
      <button id="submitBtn">Submit</button>
      <div id="status"></div>
    </div>
  </div>

<script>
  // --- Setup ---
  const wsProtocol = (location.protocol === 'https:') ? 'wss://' : 'ws://';
  const ws = new WebSocket(wsProtocol + location.host);

  const clientId = Math.random().toString(36).slice(2,9);
  const nameInput = document.getElementById('name');
  const playersEl = document.getElementById('players');
  const phaseInfoEl = document.getElementById('phaseInfo');
  const chainEl = document.getElementById('chain');
  const inputText = document.getElementById('inputText');
  const inputCanvas = document.getElementById('inputCanvas');
  const submitBtn = document.getElementById('submitBtn');
  const statusEl = document.getElementById('status');

  // Drawing setup on inputCanvas
  const ctx = inputCanvas.getContext('2d');
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  let drawing = false;
  let brush = { color: '#000000', size: 3 };
  let drawCommands = [];

  function toCanvasPos(e) {
    const rect = inputCanvas.getBoundingClientRect();
    const scaleX = inputCanvas.width / rect.width;
    const scaleY = inputCanvas.height / rect.height;
    const x = ((e.clientX ?? (e.touches && e.touches[0].clientX)) - rect.left) * scaleX;
    const y = ((e.clientY ?? (e.touches && e.touches[0].clientY)) - rect.top) * scaleY;
    return { x, y };
  }

  function beginStroke(pt) {
    drawing = true;
    drawCommands.push({ x: pt.x, y: pt.y, type: 'begin' });
    ctx.beginPath();
    ctx.moveTo(pt.x, pt.y);
  }

  function strokeTo(pt) {
    drawCommands.push({ x: pt.x, y: pt.y, type: 'stroke' });
    ctx.lineTo(pt.x, pt.y);
    ctx.stroke();
  }

  function endStroke() {
    drawing = false;
    drawCommands.push({ type: 'end' });
    ctx.closePath();
  }

  inputCanvas.addEventListener('pointerdown', e => {
    if (!canDraw) return;
    const pt = toCanvasPos(e);
    beginStroke(pt);
    e.preventDefault();
  });

  inputCanvas.addEventListener('pointermove', e => {
    if (!drawing || !canDraw) return;
    const pt = toCanvasPos(e);
    strokeTo(pt);
    e.preventDefault();
  });

  window.addEventListener('pointerup', e => {
    if (drawing && canDraw) endStroke();
  });

  // --- State ---
  let players = {};
  let playerOrder = [];
  let chain = [];
  let currentPhase = 0;
  let currentPlayerId = null;
  let currentInputType = null; // 'text' or 'drawing'
  let canDraw = false;

  // --- Functions ---

  function renderChain() {
    chainEl.innerHTML = '';
    chain.forEach((entry, i) => {
      const div = document.createElement('div');
      div.className = 'chain-entry';

      if (entry.type === 'text') {
        div.textContent = `Text: ${entry.content}`;
      } else if (entry.type === 'drawing') {
        const c = document.createElement('canvas');
        c.className = 'chain-canvas';
        c.width = 300;
        c.height = 200;
        div.appendChild(c);

        const ctx = c.getContext('2d');
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.strokeStyle = entry.brush.color;
        ctx.lineWidth = entry.brush.size;

        ctx.beginPath();
        entry.commands.forEach(cmd => {
          if (cmd.type === 'begin') ctx.moveTo(cmd.x, cmd.y);
          else if (cmd.type === 'stroke') ctx.lineTo(cmd.x, cmd.y);
          else if (cmd.type === 'end') ctx.closePath();
        });
        ctx.stroke();
      }

      chainEl.appendChild(div);
    });
  }

  function resetInput() {
    inputText.value = '';
    drawCommands = [];
    ctx.clearRect(0, 0, inputCanvas.width, inputCanvas.height);
  }

  function enableInput(type, isCurrentPlayer) {
    currentInputType = type;
    canDraw = isCurrentPlayer;

    if (type === 'text') {
      inputText.style.display = 'block';
      inputCanvas.style.display = 'none';
      inputText.disabled = !isCurrentPlayer;
    } else if (type === 'drawing') {
      inputText.style.display = 'none';
      inputCanvas.style.display = 'block';
    }

    submitBtn.disabled = !isCurrentPlayer;
    resetInput();

    if (isCurrentPlayer) {
      statusEl.textContent = `Your turn to ${type === 'text' ? 'write' : 'draw'}.`;
    } else {
      statusEl.textContent = `Waiting for other player to ${type === 'text' ? 'write' : 'draw'}...`;
    }
  }

  function announce(text) {
    if ('speechSynthesis' in window) {
      speechSynthesis.cancel();
      const utterance = new SpeechSynthesisUtterance(text);
      speechSynthesis.speak(utterance);
    }
  }

  submitBtn.addEventListener('click', () => {
    if (!canDraw) return;

    if (currentInputType === 'text') {
      const content = inputText.value.trim();
      if (!content) {
        alert('Please enter some text');
        return;
      }
      ws.send(JSON.stringify({
        t: 'input',
        id: clientId,
        type: 'text',
        content,
      }));
      enableInput(null, false);
    } else if (currentInputType === 'drawing') {
      if (drawCommands.length === 0) {
        alert('Please draw something');
        return;
      }
      ws.send(JSON.stringify({
        t: 'input',
        id: clientId,
        type: 'drawing',
        commands: drawCommands,
        brush,
      }));
      enableInput(null, false);
    }
  });

  // --- WebSocket events ---

  ws.addEventListener('open', () => {
    ws.send(JSON.stringify({ t: 'meta', id: clientId, name: nameInput.value || 'anon' }));
  });

  nameInput.addEventListener('change', () => {
    ws.send(JSON.stringify({ t: 'meta', id: clientId, name: nameInput.value || 'anon' }));
  });

  ws.addEventListener('message', ev => {
    let msg;
    try {
      msg = JSON.parse(ev.data);
    } catch {
      return;
    }

    if (msg.t === 'players') {
      players = msg.players || {};
      playerOrder = msg.order || [];
      playersEl.textContent = playerOrder.map(id => players[id] || id).join('\n');
      return;
    }

    if (msg.t === 'chainUpdate') {
      chain = msg.chain || [];
      renderChain();
      return;
    }

    if (msg.t === 'phaseStart') {
      currentPhase = msg.phase;
      currentPlayerId = msg.playerId;
      currentInputType = msg.inputType;

      const currName = players[currentPlayerId] || currentPlayerId || 'Unknown';
      phaseInfoEl.textContent = `Phase ${currentPhase + 1}: ${currName} to ${currentInputType === 'text' ? 'write' : 'draw'}`;

      enableInput(currentInputType, clientId === currentPlayerId);

      if (clientId === currentPlayerId) {
        announce(`Your turn to ${currentInputType === 'text' ? 'write' : 'draw'}`);
      }
      return;
    }
  });
</script>
</body>
</html>
