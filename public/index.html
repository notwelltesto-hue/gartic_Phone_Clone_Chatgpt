<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gartic Phone - Secret Phases Prototype</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div id="container">
    <h1>Gartic Phone</h1>
    <label for="name">Enter your name:</label>
    <input
      type="text"
      id="name"
      placeholder="Your name here..."
      maxlength="20"
      autocomplete="off"
      spellcheck="false"
    />

    <div id="players">(Waiting for players...)</div>

    <div id="phaseInfo">Waiting for enough players...</div>
    <div id="timer"></div>

    <div id="inputSection">
      <textarea
        id="inputText"
        placeholder="Type your prompt or description here..."
      ></textarea>
      <canvas id="inputCanvas" width="320" height="220"></canvas>
      <button id="submitBtn" disabled>Submit</button>
      <div id="status"></div>
    </div>

    <div id="chain"></div>
  </div>

  <script>
    (() => {
      const wsProtocol = location.protocol === 'https:' ? 'wss://' : 'ws://';
      const ws = new WebSocket(wsProtocol + location.host);

      // Elements
      const nameInput = document.getElementById('name');
      const playersEl = document.getElementById('players');
      const phaseInfoEl = document.getElementById('phaseInfo');
      const timerEl = document.getElementById('timer');
      const inputText = document.getElementById('inputText');
      const inputCanvas = document.getElementById('inputCanvas');
      const submitBtn = document.getElementById('submitBtn');
      const statusEl = document.getElementById('status');
      const chainEl = document.getElementById('chain');

      // Client state
      const clientId = Math.random().toString(36).slice(2, 9);
      let players = {};
      let playerOrder = [];
      let chain = [];
      let currentPhase = -1;
      let currentPlayerId = null;
      let currentInputType = null;
      let canInput = false;

      // Drawing setup
      const ctx = inputCanvas.getContext('2d');
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.strokeStyle = '#f5a623';
      ctx.lineWidth = 3;

      let drawing = false;
      let drawCommands = [];

      // Utility for mouse/touch position
      function toCanvasPos(e) {
        const rect = inputCanvas.getBoundingClientRect();
        const scaleX = inputCanvas.width / rect.width;
        const scaleY = inputCanvas.height / rect.height;
        const x =
          ((e.clientX ?? (e.touches && e.touches[0].clientX)) - rect.left) * scaleX;
        const y =
          ((e.clientY ?? (e.touches && e.touches[0].clientY)) - rect.top) * scaleY;
        return { x, y };
      }

      function beginStroke(pt) {
        drawing = true;
        drawCommands.push({ x: pt.x, y: pt.y, type: 'begin' });
        ctx.beginPath();
        ctx.moveTo(pt.x, pt.y);
      }

      function strokeTo(pt) {
        drawCommands.push({ x: pt.x, y: pt.y, type: 'stroke' });
        ctx.lineTo(pt.x, pt.y);
        ctx.stroke();
      }

      function endStroke() {
        drawing = false;
        drawCommands.push({ type: 'end' });
        ctx.closePath();
      }

      // Input canvas event handlers
      inputCanvas.addEventListener('pointerdown', (e) => {
        if (!canInput) return;
        beginStroke(toCanvasPos(e));
        e.preventDefault();
      });
      inputCanvas.addEventListener('pointermove', (e) => {
        if (!drawing || !canInput) return;
        strokeTo(toCanvasPos(e));
        e.preventDefault();
      });
      window.addEventListener('pointerup', (e) => {
        if (drawing && canInput) endStroke();
      });

      // Render chain
      function renderChain() {
        chainEl.innerHTML = '';
        chain.forEach((entry, idx) => {
          const div = document.createElement('div');
          div.className = 'chain-entry';

          if (entry.type === 'text') {
            div.innerHTML = `<div class="chain-text">${entry.content}</div>`;
          } else if (entry.type === 'drawing') {
            const c = document.createElement('canvas');
            c.className = 'chain-canvas';
            c.width = 320;
            c.height = 220;
            div.appendChild(c);

            const ctx2 = c.getContext('2d');
            ctx2.lineCap = 'round';
            ctx2.lineJoin = 'round';
            ctx2.strokeStyle = entry.brush.color;
            ctx2.lineWidth = entry.brush.size;

            ctx2.beginPath();
            entry.commands.forEach((cmd) => {
              if (cmd.type === 'begin') ctx2.moveTo(cmd.x, cmd.y);
              else if (cmd.type === 'stroke') ctx2.lineTo(cmd.x, cmd.y);
              else if (cmd.type === 'end') ctx2.closePath();
            });
            ctx2.stroke();
          }

          chainEl.appendChild(div);
        });
      }

      function resetInput() {
        inputText.value = '';
        drawCommands = [];
        ctx.clearRect(0, 0, inputCanvas.width, inputCanvas.height);
      }

      function setInput(type, isCurrentPlayer) {
        currentInputType = type;
        canInput = isCurrentPlayer;

        if (!isCurrentPlayer) {
          // Hide inputs if not current player
          inputText.style.display = 'none';
          inputCanvas.style.display = 'none';
          submitBtn.disabled = true;
          statusEl.textContent = `Waiting for player "${
            players[currentPlayerId] || 'Unknown'
          }" to ${type === 'text' ? 'write' : 'draw'}...`;
          return;
        }

        // Show only the relevant input
        if (type === 'text') {
          inputText.style.display = 'block';
          inputCanvas.style.display = 'none';
          inputText.disabled = false;
          inputText.focus();
        } else if (type === 'drawing') {
          inputText.style.display = 'none';
          inputCanvas.style.display = 'block';
        }

        submitBtn.disabled = false;
        resetInput();

        statusEl.textContent = `Your turn to ${
          type === 'text' ? 'write a prompt' : 'draw the prompt'
        }.`;
      }

      // Countdown timer display
      let timerInterval = null;
      let phaseEndTime = 0;
      function startTimer() {
        clearInterval(timerInterval);
        phaseEndTime = Date.now() + 30000;
        timerEl.textContent = 'Time left: 30s';

        timerInterval = setInterval(() => {
          const diff = Math.max(0, phaseEndTime - Date.now());
          const seconds = Math.ceil(diff / 1000);
          timerEl.textContent = `Time left: ${seconds}s`;
          if (diff <= 0) clearInterval(timerInterval);
        }, 200);
      }

      function stopTimer() {
        clearInterval(timerInterval);
        timerEl.textContent = '';
      }

      // Text-to-speech
      function announce(text) {
        if ('speechSynthesis' in window) {
          speechSynthesis.cancel();
          const utterance = new SpeechSynthesisUtterance(text);
          speechSynthesis.speak(utterance);
        }
      }

      submitBtn.addEventListener('click', () => {
        if (!canInput) return;

        if (currentInputType === 'text') {
          const content = inputText.value.trim();
          if (!content) {
            alert('Please enter some text');
            return;
          }
          ws.send(
            JSON.stringify({
              t: 'input',
              id: clientId,
              type: 'text',
              content,
            }),
          );
          setInput(null, false);
          stopTimer();
        } else if (currentInputType === 'drawing') {
          if (drawCommands.length === 0) {
            alert('Please draw something');
            return;
          }
          ws.send(
            JSON.stringify({
              t: 'input',
              id: clientId,
              type: 'drawing',
              commands: drawCommands,
              brush: { color: ctx.strokeStyle, size: ctx.lineWidth },
            }),
          );
          setInput(null, false);
          stopTimer();
        }
      });

      nameInput.addEventListener('change', () => {
        ws.send(
          JSON.stringify({ t: 'join', id: clientId, name: nameInput.value || '' }),
        );
      });

      ws.addEventListener('open', () => {
        ws.send(JSON.stringify({ t: 'join', id: clientId, name: nameInput.value || '' }));
      });

      ws.addEventListener('message', (ev) => {
        let msg;
        try {
          msg = JSON.parse(ev.data);
        } catch {
          return;
        }

        if (msg.t === 'playersUpdate') {
          players = msg.players || {};
          playerOrder = msg.order || [];

          if (playerOrder.length === 0) {
            playersEl.textContent = '(Waiting for players...)';
          } else {
            playersEl.innerHTML = playerOrder
              .map((id) => {
                const cls = id === currentPlayerId ? 'player-name player-current' : 'player-name';
                return `<div class="${cls}">${players[id] || id}</div>`;
              })
              .join('');
          }
          return;
        }

        if (msg.t === 'chainUpdate') {
          chain = msg.chain || [];
          renderChain();
          return;
        }

        if (msg.t === 'phaseStart') {
          currentPhase = msg.phaseIndex;
          currentPlayerId = msg.playerId;
          currentInputType = msg.inputType;

          const currentPlayerName = players[currentPlayerId] || 'Unknown';
          phaseInfoEl.textContent = `Phase ${currentPhase + 1}: ${currentPlayerName} to ${
            currentInputType === 'text' ? 'write' : 'draw'
          }`;

          setInput(currentInputType, clientId === currentPlayerId);
          if (clientId === currentPlayerId) {
            announce(
              `Your turn to ${currentInputType === 'text' ? 'write' : 'draw'}`,
            );
          }
          startTimer();
        }
      });
    })();
  </script>
</body>
</html>
